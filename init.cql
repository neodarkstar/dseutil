CREATE KEYSPACE IF NOT EXISTS <KEYSPACE> WITH REPLICATION = { 'class' : '<STRATEGY>', '<DATACENTER>' : <REPLICATION_FACTOR> };
CREATE TABLE IF NOT EXISTS <KEYSPACE>.attribute ( lid text, bid text, gid text, creation timestamp, kind tinyint, name text, description text, type int, as_on timestamp, multi_value boolean, retired boolean, category tinyint, external_id text, ac_profiled boolean, PRIMARY KEY (lid) );
CREATE TABLE IF NOT EXISTS <KEYSPACE>.type ( id text, as_on timestamp, name text, description text, attributes set<text>, open boolean, version bigint, PRIMARY KEY (id, version) ) WITH CLUSTERING ORDER BY (version DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.time_series_label ( id text, name text, as_on timestamp, PRIMARY KEY (id) );
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ado ( lid text, gid text, bid text, creation timestamp, deleted int, active boolean, type_id text, activation_started boolean, last_op_as_on timestamp, version bigint, PRIMARY KEY (lid) );
CREATE TYPE <KEYSPACE>.translation ( src bigint, id text, value text, comment text );
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ado_data ( lid text, as_of timestamp, creation timestamp, gid text, bid text, acx_time timestamp, type_id text, double_attributes map<text, text>, integer_attributes map<text, text>, text_attributes map<text, text>, boolean_attributes map<text, text>, blob_attributes frozen<map<text, frozen<list<blob>>>>, status frozen<map<text, frozen<list<int>>>>, na frozen<map<text, frozen<list<boolean>>>>, attribute_as_on frozen<map<text, timestamp>>, tr_codes_as_on frozen<map<bigint, timestamp>>, deleted_codes frozen<list<bigint>>, translations list<frozen<translation>>, version bigint STATIC, PRIMARY KEY (lid, as_of) ) WITH CLUSTERING ORDER BY (as_of DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ado_operation_history ( ado_lid text, op smallint, ado_bid text, as_on timestamp, acx_time timestamp, changed_by_service smallint, PRIMARY KEY (ado_lid, op, as_on) ) WITH CLUSTERING ORDER BY (op DESC, as_on DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ado_attribute_history ( ado_lid text, attribute_id text, as_on timestamp, acx_time timestamp, ado_bid text, op smallint, start timestamp, expiry timestamp, double_attribute frozen<list<double>>, integer_attribute frozen<list<bigint>>, text_attribute frozen<list<text>>, boolean_attribute frozen<list<boolean>>, blob_attribute frozen<list<blob>>, btext_attribute frozen<list<blob>>, status frozen<list<int>>, na frozen<list<boolean>>, changed_by_service smallint, PRIMARY KEY (ado_lid, attribute_id, as_on, acx_time) ) WITH CLUSTERING ORDER BY (attribute_id DESC, as_on DESC, acx_time DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ado_history_as_on_index ( as_on_year int, as_on timestamp, ado_lid text, ado_bid text, PRIMARY KEY (as_on_year, as_on, ado_lid) ) WITH CLUSTERING ORDER BY (as_on DESC, ado_lid DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ado_atribute_as_on_index ( ado_lid text, as_on timestamp, acx_time timestamp, attribute_id text, PRIMARY KEY (ado_lid, as_on, acx_time, attribute_id) ) WITH CLUSTERING ORDER BY (as_on DESC, acx_time DESC, attribute_id DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ado_attribute_history_start_index ( ado_lid text, start timestamp, attribute_id text, as_on timestamp, expiry timestamp, PRIMARY KEY (ado_lid, start, attribute_id, as_on) ) WITH CLUSTERING ORDER BY (start DESC, attribute_id DESC, as_on DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ado_translation_code_history ( ado_lid text, source bigint, id text, code text, comment text, as_on timestamp, acx_time timestamp, ado_bid text, op smallint, start timestamp, expiry timestamp, changed_by_service smallint, PRIMARY KEY (ado_lid, as_on, start, acx_time, source) ) WITH CLUSTERING ORDER BY (as_on DESC, start DESC, acx_time DESC, source DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.ts_def_ado_index ( ado_gid text, label_id text, as_on timestamp, def_id text, PRIMARY KEY (ado_gid, label_id, as_on) ) WITH CLUSTERING ORDER BY (label_id DESC, as_on desc);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.time_series_definition ( id text, ado_gid text STATIC, label_id text STATIC, creation timestamp STATIC, attributes frozen<list<text>>, aliases frozen<list<int>>, last_alias int, as_on timestamp, category text, operation smallint, PRIMARY KEY (id, as_on) ) WITH CLUSTERING ORDER BY (as_on DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.time_series_truncate ( tsdef_id text, as_on timestamp, from_as_of timestamp, to_as_of timestamp, acx_time timestamp, kind smallint, PRIMARY KEY (tsdef_id, as_on, acx_time) ) WITH CLUSTERING ORDER BY (as_on DESC, acx_time DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.correction_record ( tsdef_id text, as_on timestamp, as_of timestamp, factors map<text, double>, acx_time timestamp, operation smallint, PRIMARY KEY (tsdef_id, as_on, as_of) ) WITH CLUSTERING ORDER BY (as_on DESC, as_of DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.time_series_history ( tsdef_id text, as_of_year int, as_of timestamp, as_on timestamp, acx_time timestamp, deleted int, double_attributes map<text, double>, integer_attributes map<text, bigint>, text_attributes map<text, text>, boolean_attributes map<text, boolean>, blob_attributes map<text, blob>, status map<text, int>, na map<text, boolean>, PRIMARY KEY ((tsdef_id, as_of_year), as_of, as_on, acx_time) ) WITH CLUSTERING ORDER BY (as_of DESC, as_on DESC, acx_time DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.derived_time_series ( tsdef_id text, as_of_year int, as_of timestamp, as_on timestamp, acx_time timestamp, double_attributes map<text, double>, integer_attributes map<text, bigint>, text_attributes map<text, text>, boolean_attributes map<text, boolean>, blob_attributes map<text, blob>, status map<text, int>, na map<text, boolean>, PRIMARY KEY ((tsdef_id, as_of_year), as_on, as_of, acx_time) ) WITH CLUSTERING ORDER BY (as_on DESC,as_of DESC, acx_time DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.derived_time_series_as_on ( tsdef_id text, as_on timestamp, status smallint, PRIMARY KEY (tsdef_id, as_on) ) WITH CLUSTERING ORDER BY (as_on DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.derived_time_series_segment ( tsdef_id text, start_as_of timestamp, as_on timestamp, end_as_of timestamp, PRIMARY KEY (tsdef_id, start_as_of, as_on) ) WITH CLUSTERING ORDER BY (start_as_of DESC,as_on DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.time_series_info ( tsdef_id text PRIMARY KEY, as_of_start_year int, as_of_end_year int, version bigint );
CREATE TABLE IF NOT EXISTS <KEYSPACE>.merkle_trees ( id text, label text, as_on timestamp, tree text, PRIMARY KEY (id, label, as_on) ) WITH CLUSTERING ORDER BY (label asc, as_on desc);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.business_id_index ( kind smallint, bid text, as_on timestamp, lid text, op smallint, gid text static, PRIMARY KEY ((kind, bid), as_on) ) WITH CLUSTERING ORDER BY (as_on desc);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.lives_index ( gid text, kind smallint, as_on timestamp, lid text, PRIMARY KEY ((kind, gid), as_on, lid) ) WITH CLUSTERING ORDER BY (as_on desc, lid desc);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.list_data ( lid text, as_on timestamp, acx_time timestamp, creation timestamp static, gid text static, bid text static, op smallint, type smallint static, category smallint static, leaves frozen<list<text>>, null_leaves boolean, lists frozen<list<text>>, null_lists boolean, description text, PRIMARY KEY (lid, as_on) ) WITH CLUSTERING ORDER BY (as_on desc);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.list_index ( lid text, type smallint, deleted boolean, bid text, as_on timestamp, PRIMARY KEY (type, deleted, lid, bid) ) WITH CLUSTERING ORDER BY (deleted DESC, lid DESC, bid DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.list_child_parent_index ( child text, type smallint, as_on timestamp, parent_lid text, op smallint, PRIMARY KEY ((child, type), as_on, parent_lid) ) WITH CLUSTERING ORDER BY (as_on desc, parent_lid desc);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.calendar_data ( calendar_lid text, bid text, gid text, creation timestamp, name text, weekdays tinyint, as_on timestamp, acx_time timestamp, PRIMARY KEY (calendar_lid, as_on) ) WITH CLUSTERING ORDER BY (as_on DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.calendar_holiday ( calendar_lid text, date date, as_on timestamp, name text, acx_time timestamp, deleted boolean, PRIMARY KEY (calendar_lid, as_on, date) ) WITH CLUSTERING ORDER BY (as_on DESC, date DESC);
CREATE TABLE IF NOT EXISTS <KEYSPACE>.id_seq ( namespace text, value bigint, PRIMARY KEY (namespace) ) ;
CREATE SEARCH INDEX IF NOT EXISTS ON <KEYSPACE>.ado_data WITH COLUMNS as_of, acx_time,bid, gid, creation,text_attributes, integer_attributes, double_attributes, boolean_attributes AND CONFIG {} AND OPTIONS { lenient: true };
ALTER SEARCH INDEX CONFIG ON <KEYSPACE>.ado_data ADD fieldInputTransformer[@name='dse', @class='com.acx.dse.ACXInputTransformer'];
ALTER SEARCH INDEX CONFIG ON <KEYSPACE>.ado_data ADD fieldOutputTransformer[@name='dse', @class='com.acx.dse.ACXOutputTransformer'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD types.fieldType[@class='org.apache.solr.schema.TrieDoubleField', @name='TrieDoubleField'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD types.fieldType[@class='org.apache.solr.schema.TrieLongField', @name='TrieLongField'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD types.fieldType[@class='org.apache.solr.schema.BoolField', @name='BoolField'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD fields.dynamicField[@indexed='true', @multiValued='true', @name='*_text', @stored='true', @type='StrField'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD fields.dynamicField[@indexed='true', @multiValued='true', @name='*_double', @stored='true', @type='TrieDoubleField'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD fields.dynamicField[@indexed='true', @multiValued='true', @name='*_integer', @stored='true', @type='TrieLongField'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD fields.dynamicField[@indexed='true', @multiValued='true', @name='*_boolean', @stored='true', @type='BoolField'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data SET field[@name = 'lid']@docValues = 'true';
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD types.fieldType[@class='com.datastax.bdp.search.solr.core.types.TupleField', @name='UDTField'];
ALTER SEARCH INDEX SCHEMA ON <KEYSPACE>.ado_data ADD field translations;
RELOAD SEARCH INDEX ON <KEYSPACE>.ado_data;
REBUILD SEARCH INDEX ON <KEYSPACE>.ado_data;
INSERT INTO <KEYSPACE>.business_id_index (kind, bid, as_on, lid, op, gid) VALUES (3, 'prop.longname', '1970-01-01 00:00:00.000Z', 's1', 1, 's0');
INSERT INTO <KEYSPACE>.lives_index (gid, kind, as_on, lid) VALUES ('s0', 3, '1970-01-01 00:00:00.000Z', 's1');
INSERT INTO <KEYSPACE>.attribute (lid, bid, gid,creation, kind, description, external_id, name, multi_value, retired, type, as_on) VALUES ('s1','prop.longname','s0', '1970-01-01 00:00:00.000Z', 3, 'ADO Longname property', 'Aprop.longname', 'Longname', false, false, 3, '1970-01-01 00:00:00.000Z');
INSERT INTO <KEYSPACE>.business_id_index (kind, bid, as_on, lid, op, gid) VALUES (3, 'prop.template', '1970-01-01 00:00:00.000Z', 's3', 1, 's2');
INSERT INTO <KEYSPACE>.attribute (lid, bid, gid, creation, kind, description, external_id, name, multi_value, retired, type, as_on) VALUES ('s3', 'prop.template', 's2', '1970-01-01 00:00:00.000Z', 3, 'ADO Template Id property', 'Aprop.template', 'Template Id', false, false, 3, '1970-01-01 00:00:00.000Z');
INSERT INTO <KEYSPACE>.lives_index (gid, kind, as_on, lid) VALUES ('s2', 3, '1970-01-01 00:00:00.000Z', 's3');
INSERT INTO <KEYSPACE>.type (id, version, name, description, as_on) VALUES ('TOP', 0, 'Top ADO Type', 'A type that allows all attributes without restrictions', '1970-01-01 00:00:00.000Z');
INSERT INTO <KEYSPACE>.id_seq (namespace, value) VALUES ('staticAttr', 20);
INSERT INTO <KEYSPACE>.id_seq (namespace, value) VALUES ('dynAttr', 20);
CREATE INDEX attribute_name_index ON <KEYSPACE>.attribute(name);
CREATE INDEX attribute_bid_index ON <KEYSPACE>.attribute(bid);